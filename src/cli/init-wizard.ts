/**
 * Interactive init wizard for discoclaw.
 * Invoked by `discoclaw init` to guide a first-time user through setup.
 * Creates a .env file and scaffolds a workspace/ directory in the current
 * working directory.
 */

import * as readline from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { execFileSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import { validateDiscordToken, validateSnowflake, validateSnowflakes } from '../validate.js';
import { ensureWorkspaceBootstrapFiles } from '../workspace-bootstrap.js';

// ── helpers ───────────────────────────────────────────────────────────────────

function which(bin: string): boolean {
  try {
    const finder = process.platform === 'win32' ? 'where' : 'which';
    execFileSync(finder, [bin], { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

export function backupFileName(now = new Date()): string {
  const ts = now.toISOString().replace(/[-:]/g, '').replace(/\.\d+Z$/, '');
  return `.env.backup.${ts}`;
}

export function buildEnvContent(vals: Record<string, string>, now = new Date()): string {
  const lines: string[] = [
    '# Discoclaw — generated by discoclaw init',
    `# Created: ${now.toISOString()}`,
    '',
  ];

  lines.push('# REQUIRED');
  lines.push(`DISCORD_TOKEN=${vals.DISCORD_TOKEN ?? ''}`);
  lines.push(`DISCORD_ALLOW_USER_IDS=${vals.DISCORD_ALLOW_USER_IDS ?? ''}`);
  if (vals.DISCOCLAW_DATA_DIR) {
    lines.push(`DISCOCLAW_DATA_DIR=${vals.DISCOCLAW_DATA_DIR}`);
  }
  lines.push('');

  if (vals.PRIMARY_RUNTIME) {
    const providerSpecificKeys = [
      'GEMINI_BIN',
      'GEMINI_MODEL',
      'OPENAI_API_KEY',
      'CODEX_BIN',
      'CODEX_MODEL',
      'CODEX_DANGEROUSLY_BYPASS_APPROVALS_AND_SANDBOX',
      'CLAUDE_DANGEROUSLY_SKIP_PERMISSIONS',
      'CLAUDE_OUTPUT_FORMAT',
      'OPENROUTER_API_KEY',
      'OPENROUTER_BASE_URL',
      'OPENROUTER_MODEL',
    ];
    lines.push('# PROVIDER');
    lines.push(`PRIMARY_RUNTIME=${vals.PRIMARY_RUNTIME}`);
    for (const k of providerSpecificKeys) {
      if (vals[k]) lines.push(`${k}=${vals[k]}`);
    }
    lines.push('');
    if (vals.DISCORD_GUILD_ID) {
      lines.push('# CORE');
      lines.push(`DISCORD_GUILD_ID=${vals.DISCORD_GUILD_ID}`);
      lines.push('');
    }
  }

  lines.push('# DEFAULTS');
  lines.push(`DISCOCLAW_DISCORD_ACTIONS=${vals.DISCOCLAW_DISCORD_ACTIONS ?? '1'}`);
  lines.push('');

  // Voice
  const voiceKeys = [
    'DISCOCLAW_VOICE_ENABLED',
    'DEEPGRAM_API_KEY',
    'DISCOCLAW_DISCORD_ACTIONS_VOICE',
    'DISCOCLAW_STT_PROVIDER',
    'DISCOCLAW_TTS_PROVIDER',
  ];
  const hasVoice = voiceKeys.some((k) => vals[k]);
  if (hasVoice) {
    lines.push('# VOICE');
    for (const k of voiceKeys) {
      if (vals[k]) lines.push(`${k}=${vals[k]}`);
    }
    lines.push('');
  }

  const autoDetectedKeys = ['DISCOCLAW_TASKS_FORUM', 'DISCOCLAW_CRON_FORUM'];
  const hasAutoDetected = autoDetectedKeys.some((k) => vals[k]);
  if (hasAutoDetected) {
    lines.push('# AUTO-DETECTED');
    for (const k of autoDetectedKeys) {
      if (vals[k]) lines.push(`${k}=${vals[k]}`);
    }
    lines.push('');
  }

  lines.push('# For all options, see .env.example.full');
  lines.push('');

  return lines.join('\n');
}

export function selectDefaultProvider(detected: string[]): '1' | '2' | '4' {
  if (detected.includes('claude')) return '1';
  if (detected.includes('gemini')) return '2';
  if (detected.includes('codex')) return '4';
  return '1';
}

// ── main wizard ───────────────────────────────────────────────────────────────

export async function runInitWizard(): Promise<void> {
  if (!input.isTTY) {
    console.error('discoclaw init requires an interactive terminal.\n');
    process.exit(1);
  }

  let cwd = process.cwd();
  let rl: readline.Interface | null = null;
  let canceled = false;
  let completed = false;

  function cleanup(): void {
    canceled = true;
    try {
      fs.unlinkSync(path.join(cwd, '.env.tmp'));
    } catch {
      /* ignore */
    }
    if (rl) {
      const toClose = rl;
      rl = null;
      toClose.close();
    }
    console.log('\n\nSetup canceled.\n');
    process.exit(1);
  }

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);

  rl = readline.createInterface({ input, output });
  rl.on('close', () => {
    if (!canceled && !completed) cleanup();
  });

  async function ask(prompt: string): Promise<string> {
    if (canceled || !rl) return '';
    return rl.question(prompt);
  }

  async function askValidated(
    prompt: string,
    validate: (val: string) => string | null,
  ): Promise<string> {
    while (true) {
      if (canceled) return '';
      const val = await ask(prompt);
      const err = validate(val.trim());
      if (!err) return val.trim();
      console.log(`  Error: ${err}. Try again.\n`);
    }
  }

  // ── Welcome ──────────────────────────────────────────────────────────────

  console.log(`\nDiscoclaw Init\n==============`);
  const installDirInput = await ask(`Install directory [${cwd}]: `);
  if (installDirInput.trim()) {
    cwd = path.resolve(installDirInput.trim());
    if (!fs.existsSync(cwd)) {
      fs.mkdirSync(cwd, { recursive: true });
    }
  }
  console.log(`This wizard creates a .env file and workspace/ directory in:\n  ${cwd}\n`);

  // ── Discord bot guidance ──────────────────────────────────────────────────

  console.log(
    `Discord Bot Setup\n-----------------\n` +
      `If you haven't created a Discord bot yet, follow these steps:\n\n` +
      `  1. Go to https://discord.com/developers/applications\n` +
      `  2. Click "New Application" and give it a name (e.g. "DiscoClaw").\n` +
      `  3. Open the "Bot" tab and click "Add Bot".\n` +
      `  4. Enable "Message Content Intent" under Privileged Gateway Intents.\n` +
      `  5. Click "Reset Token", copy it — you'll enter it below.\n` +
      `  6. Invite your bot: Bot tab → OAuth2 → URL Generator\n` +
      `     Scopes: bot   Permissions: View Channels, Send Messages,\n` +
      `     Read Message History, Manage Channels, Manage Threads,\n` +
      `     Send Messages in Threads\n` +
      `     Open the generated URL and select your server.\n\n` +
      `Already have a bot? Just press Enter.\n`,
  );

  await ask('Press Enter to continue... ');

  // ── Data directory ────────────────────────────────────────────────────────

  const defaultDataDir = path.join(cwd, 'data');
  const dataDirInput = await ask(`Data directory [${defaultDataDir}]: `);
  const dataDir = dataDirInput.trim() || defaultDataDir;

  // ── Collected values ──────────────────────────────────────────────────────

  const values: Record<string, string> = {};
  values.DISCOCLAW_DATA_DIR = dataDir;

  // ── Check existing .env ───────────────────────────────────────────────────

  const envPath = path.join(cwd, '.env');

  if (fs.existsSync(envPath)) {
    const existing = fs.readFileSync(envPath, 'utf8');
    const tokenMatch = existing.match(/^DISCORD_TOKEN=(.*)$/m);
    const idsMatch = existing.match(/^DISCORD_ALLOW_USER_IDS=(.*)$/m);

    console.log('\nExisting .env detected:');
    if (tokenMatch?.[1]) {
      const t = tokenMatch[1].trim();
      console.log(`  DISCORD_TOKEN = ${t.slice(0, 8)}...(masked)`);
    } else {
      console.log('  DISCORD_TOKEN = (not set)');
    }
    if (idsMatch?.[1]) {
      const ids = idsMatch[1].trim().split(/[,\s]+/).filter(Boolean);
      const masked = ids.map((id) => (id.length > 6 ? `${id.slice(0, 3)}...${id.slice(-3)}` : '***'));
      console.log(`  DISCORD_ALLOW_USER_IDS = ${masked.join(', ')}`);
    } else {
      console.log('  DISCORD_ALLOW_USER_IDS = (not set)');
    }
    console.log('');

    const overwrite = await ask('Overwrite with fresh config? [y/N] ');
    if (overwrite.toLowerCase() !== 'y') {
      console.log('Run discoclaw init after removing .env to reconfigure.\n');
      completed = true;
      rl.close();
      return;
    }

    const bkName = backupFileName();
    const backupPath = path.join(cwd, bkName);
    fs.copyFileSync(envPath, backupPath);
    console.log(`  Backed up to ${bkName}\n`);

    // Carry forward auto-detected forum channel IDs so explicit overrides survive re-runs
    const tasksMatch = existing.match(/^DISCOCLAW_TASKS_FORUM=(.*)$/m);
    const cronMatch = existing.match(/^DISCOCLAW_CRON_FORUM=(.*)$/m);
    if (tasksMatch?.[1]?.trim()) values.DISCOCLAW_TASKS_FORUM = tasksMatch[1].trim();
    if (cronMatch?.[1]?.trim()) values.DISCOCLAW_CRON_FORUM = cronMatch[1].trim();
  }

  // ── Required values ───────────────────────────────────────────────────────

  values.DISCORD_TOKEN = await askValidated('Discord bot token: ', (val) => {
    const r = validateDiscordToken(val);
    return r.valid ? null : (r.reason ?? 'Invalid token format');
  });

  console.log(
    `\nDiscord User ID\n` +
      `  A Discord user ID is an 18-19 digit number uniquely identifying your account.\n` +
      `  To find yours: Settings → Advanced → enable Developer Mode,\n` +
      `  then right-click your username anywhere and choose "Copy User ID".\n`,
  );

  values.DISCORD_ALLOW_USER_IDS = await askValidated(
    'Allowed user IDs (comma-separated): ',
    (val) => {
      if (!val.trim()) return 'At least one user ID is required';
      const r = validateSnowflakes(val);
      if (!r.valid && r.invalidIds.length > 0) return `Invalid IDs: ${r.invalidIds.join(', ')}`;
      if (!r.valid) return 'At least one valid snowflake ID is required';
      return null;
    },
  );

  console.log(
    `\nDiscord Guild ID\n` +
      `  A Discord guild (server) ID is an 18-19 digit number uniquely identifying your server.\n` +
      `  To find yours: right-click your server name in the sidebar\n` +
      `  and choose "Copy Server ID" (requires Developer Mode enabled).\n`,
  );

  values.DISCORD_GUILD_ID = await askValidated('Discord guild (server) ID: ', (val) => {
    if (!val) return 'Guild ID is required';
    return validateSnowflake(val) ? null : 'Must be a 17-20 digit number';
  });

  // (DISCOCLAW_TASKS_FORUM and DISCOCLAW_CRON_FORUM are auto-created on first connect)

  // ── Runtime detection ─────────────────────────────────────────────────────

  const detected: string[] = [];
  if (which('claude')) detected.push('claude');
  if (which('gemini')) detected.push('gemini');
  if (which('codex')) detected.push('codex');

  if (detected.length > 0) {
    console.log(`\nDetected runtimes: ${detected.join(', ')}`);
  } else {
    console.log('\nNo AI runtimes detected in PATH.');
    console.log('  → Install Claude CLI: https://docs.anthropic.com/en/docs/claude-code');
  }

  // ── Provider selection ────────────────────────────────────────────────────

  console.log('\nSelect your AI provider:');
  console.log('  1) Claude' + (detected.includes('claude') ? ' (detected)' : ''));
  console.log('  2) Gemini' + (detected.includes('gemini') ? ' (detected)' : ''));
  console.log('  3) OpenAI');
  console.log('  4) Codex' + (detected.includes('codex') ? ' (detected)' : ''));
  console.log('  5) OpenRouter');

  const defaultProvider = selectDefaultProvider(detected);

  const providerChoice = await askValidated(
    `Provider [1-5, default: ${defaultProvider}]: `,
    (val) => {
      const effective = val || defaultProvider;
      return ['1', '2', '3', '4', '5'].includes(effective) ? null : 'Enter 1, 2, 3, 4, or 5';
    },
  );
  const finalChoice = providerChoice || defaultProvider;

  if (finalChoice === '1') {
    values.PRIMARY_RUNTIME = 'claude';
    values.CLAUDE_DANGEROUSLY_SKIP_PERMISSIONS = '1';
    values.CLAUDE_OUTPUT_FORMAT = 'stream-json';
  } else if (finalChoice === '2') {
    values.PRIMARY_RUNTIME = 'gemini';
    console.log('  Note: auth is handled by the gemini binary itself (run `gemini` to authenticate).');
    values.GEMINI_BIN = 'gemini';
    values.GEMINI_MODEL = 'gemini-2.5-pro';
  } else if (finalChoice === '3') {
    values.PRIMARY_RUNTIME = 'openai';
    console.log('  Note: the OpenAI adapter is HTTP-only.');
    values.OPENAI_API_KEY = await askValidated(
      'OpenAI API key: ',
      (val) => (val ? null : 'API key is required'),
    );
  } else if (finalChoice === '4') {
    values.PRIMARY_RUNTIME = 'codex';
  } else if (finalChoice === '5') {
    values.PRIMARY_RUNTIME = 'openrouter';
    console.log('  Note: the OpenRouter adapter is HTTP-only.');
    values.OPENROUTER_API_KEY = await askValidated(
      'OpenRouter API key: ',
      (val) => (val ? null : 'API key is required'),
    );
    values.OPENROUTER_MODEL = 'anthropic/claude-sonnet-4';
  }

  values.DISCOCLAW_DISCORD_ACTIONS = '1';

  // ── Voice setup ───────────────────────────────────────────────────────────

  const enableVoice = await ask(
    '\nEnable voice chat? (requires a Deepgram API key — you can skip this and enable later) [y/N] ',
  );
  if (enableVoice.toLowerCase() === 'y') {
    const deepgramKey = await askValidated(
      'Deepgram API key: ',
      (val) => (val ? null : 'Deepgram API key is required'),
    );
    values.DISCOCLAW_VOICE_ENABLED = '1';
    values.DEEPGRAM_API_KEY = deepgramKey;
    values.DISCOCLAW_DISCORD_ACTIONS_VOICE = '1';
    values.DISCOCLAW_STT_PROVIDER = 'deepgram';
    values.DISCOCLAW_TTS_PROVIDER = 'deepgram';
  }

  // ── Write .env ────────────────────────────────────────────────────────────

  const envContent = buildEnvContent(values);
  const tmpPath = path.join(cwd, '.env.tmp');
  fs.writeFileSync(tmpPath, envContent, 'utf8');
  fs.renameSync(tmpPath, envPath);
  console.log('\n.env written successfully.\n');

  // ── Scaffold workspace ────────────────────────────────────────────────────

  const workspaceCwd = path.join(cwd, 'workspace');
  console.log(`Scaffolding workspace at ${workspaceCwd}...`);
  const scaffolded = await ensureWorkspaceBootstrapFiles(workspaceCwd);
  if (scaffolded.length > 0) {
    console.log(`  Created: ${scaffolded.join(', ')}`);
  } else {
    console.log('  Workspace already set up — no files changed.');
  }
  console.log('');

  // ── Next steps ────────────────────────────────────────────────────────────

  let daemonHint: string;
  if (process.platform === 'darwin') {
    daemonHint = 'discoclaw install-daemon  # sets up a launchd service';
  } else if (process.platform === 'win32') {
    daemonHint = 'Run `discoclaw` directly or use a process manager (e.g. PM2).';
  } else {
    daemonHint = 'discoclaw install-daemon  # sets up a systemd user service';
  }

  console.log('Configuration complete!\n');
  console.log('Next steps:');
  console.log('  Note: The bot will auto-create its forum channels on first connect.');
  if (values.PRIMARY_RUNTIME === 'claude') {
    console.log(`  ${daemonHint}`);
  } else if (values.PRIMARY_RUNTIME === 'gemini') {
    console.log('  1. Authenticate: run `gemini` and follow the prompts.');
    console.log(`  2. ${daemonHint}`);
  } else if (values.PRIMARY_RUNTIME === 'openai') {
    console.log('  1. Verify your OPENAI_API_KEY is correct.');
    console.log(`  2. ${daemonHint}`);
  } else if (values.PRIMARY_RUNTIME === 'codex') {
    console.log('  1. Ensure the Codex binary is installed and accessible.');
    console.log(`  2. ${daemonHint}`);
  } else if (values.PRIMARY_RUNTIME === 'openrouter') {
    console.log('  1. Verify your OPENROUTER_API_KEY is correct.');
    console.log(`  2. ${daemonHint}`);
  }
  console.log('');

  completed = true;
  rl.close();
}
