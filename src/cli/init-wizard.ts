/**
 * Interactive init wizard for discoclaw.
 * Invoked by `discoclaw init` to guide a first-time user through setup.
 * Creates a .env file and scaffolds a workspace/ directory in the current
 * working directory.
 */

import * as readline from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { execFileSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import { validateDiscordToken, validateSnowflake, validateSnowflakes } from '../validate.js';
import { ensureWorkspaceBootstrapFiles } from '../workspace-bootstrap.js';

// ── helpers ───────────────────────────────────────────────────────────────────

function which(bin: string): boolean {
  try {
    const finder = process.platform === 'win32' ? 'where' : 'which';
    execFileSync(finder, [bin], { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

export function backupFileName(now = new Date()): string {
  const ts = now.toISOString().replace(/[-:]/g, '').replace(/\.\d+Z$/, '');
  return `.env.backup.${ts}`;
}

export function buildEnvContent(vals: Record<string, string>, now = new Date()): string {
  const lines: string[] = [
    '# Discoclaw — generated by discoclaw init',
    `# Created: ${now.toISOString()}`,
    '',
  ];

  lines.push('# REQUIRED');
  lines.push(`DISCORD_TOKEN=${vals.DISCORD_TOKEN ?? ''}`);
  lines.push(`DISCORD_ALLOW_USER_IDS=${vals.DISCORD_ALLOW_USER_IDS ?? ''}`);
  lines.push(`DISCOCLAW_TASKS_FORUM=${vals.DISCOCLAW_TASKS_FORUM ?? ''}`);
  lines.push(`DISCOCLAW_CRON_FORUM=${vals.DISCOCLAW_CRON_FORUM ?? ''}`);
  lines.push('');

  if (vals.PRIMARY_RUNTIME) {
    const providerSpecificKeys = [
      'GEMINI_BIN',
      'GEMINI_MODEL',
      'OPENAI_API_KEY',
      'CODEX_BIN',
      'CODEX_MODEL',
      'CODEX_DANGEROUSLY_BYPASS_APPROVALS_AND_SANDBOX',
      'CLAUDE_DANGEROUSLY_SKIP_PERMISSIONS',
      'CLAUDE_OUTPUT_FORMAT',
    ];
    lines.push('# PROVIDER');
    lines.push(`PRIMARY_RUNTIME=${vals.PRIMARY_RUNTIME}`);
    for (const k of providerSpecificKeys) {
      if (vals[k]) lines.push(`${k}=${vals[k]}`);
    }
    lines.push('');
    if (vals.DISCORD_GUILD_ID) {
      lines.push('# CORE');
      lines.push(`DISCORD_GUILD_ID=${vals.DISCORD_GUILD_ID}`);
      lines.push('');
    }
  }

  const optionalKeys = ['DISCOCLAW_DISCORD_ACTIONS', 'DISCOCLAW_STATUS_CHANNEL'];
  const hasOptional = optionalKeys.some((k) => vals[k]);
  if (hasOptional) {
    lines.push('# OPTIONAL');
    for (const k of optionalKeys) {
      if (vals[k]) lines.push(`${k}=${vals[k]}`);
    }
    lines.push('');
  }

  lines.push('# For all options, see .env.example.full');
  lines.push('');

  return lines.join('\n');
}

export function selectDefaultProvider(detected: string[]): '1' | '2' | '4' {
  if (detected.includes('claude')) return '1';
  if (detected.includes('gemini')) return '2';
  if (detected.includes('codex')) return '4';
  return '1';
}

// ── main wizard ───────────────────────────────────────────────────────────────

export async function runInitWizard(): Promise<void> {
  if (!input.isTTY) {
    console.error('discoclaw init requires an interactive terminal.\n');
    process.exit(1);
  }

  const cwd = process.cwd();
  const envPath = path.join(cwd, '.env');
  let rl: readline.Interface | null = null;
  let canceled = false;
  let completed = false;

  function cleanup(): void {
    canceled = true;
    try {
      fs.unlinkSync(path.join(cwd, '.env.tmp'));
    } catch {
      /* ignore */
    }
    if (rl) {
      const toClose = rl;
      rl = null;
      toClose.close();
    }
    console.log('\n\nSetup canceled.\n');
    process.exit(1);
  }

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);

  rl = readline.createInterface({ input, output });
  rl.on('close', () => {
    if (!canceled && !completed) cleanup();
  });

  async function ask(prompt: string): Promise<string> {
    if (canceled || !rl) return '';
    return rl.question(prompt);
  }

  async function askValidated(
    prompt: string,
    validate: (val: string) => string | null,
  ): Promise<string> {
    while (true) {
      if (canceled) return '';
      const val = await ask(prompt);
      const err = validate(val.trim());
      if (!err) return val.trim();
      console.log(`  Error: ${err}. Try again.\n`);
    }
  }

  async function askOptional(
    prompt: string,
    validate: (val: string) => string | null,
  ): Promise<string> {
    while (true) {
      if (canceled) return '';
      const val = await ask(prompt);
      if (!val.trim()) return '';
      const err = validate(val.trim());
      if (!err) return val.trim();
      console.log(`  Error: ${err}. Try again.\n`);
    }
  }

  // ── Welcome ──────────────────────────────────────────────────────────────

  console.log(
    `\nDiscoclaw Init\n==============\n` +
      `This wizard creates a .env file and workspace/ directory in:\n  ${cwd}\n`,
  );

  // ── Discord bot guidance ──────────────────────────────────────────────────

  console.log(
    `Discord Bot Setup\n-----------------\n` +
      `If you haven't created a Discord bot yet, follow these steps:\n\n` +
      `  1. Go to https://discord.com/developers/applications\n` +
      `  2. Click "New Application" and give it a name (e.g. "DiscoClaw").\n` +
      `  3. Open the "Bot" tab and click "Add Bot".\n` +
      `  4. Enable "Message Content Intent" under Privileged Gateway Intents.\n` +
      `  5. Click "Reset Token", copy it — you'll enter it below.\n` +
      `  6. Invite your bot: Bot tab → OAuth2 → URL Generator\n` +
      `     Scopes: bot   Permissions: Send Messages, Read Message History\n` +
      `     Open the generated URL and select your server.\n\n` +
      `Already have a bot? Just press Enter.\n`,
  );

  await ask('Press Enter to continue... ');

  // ── Check existing .env ───────────────────────────────────────────────────

  if (fs.existsSync(envPath)) {
    const existing = fs.readFileSync(envPath, 'utf8');
    const tokenMatch = existing.match(/^DISCORD_TOKEN=(.*)$/m);
    const idsMatch = existing.match(/^DISCORD_ALLOW_USER_IDS=(.*)$/m);

    console.log('\nExisting .env detected:');
    if (tokenMatch?.[1]) {
      const t = tokenMatch[1].trim();
      console.log(`  DISCORD_TOKEN = ${t.slice(0, 8)}...(masked)`);
    } else {
      console.log('  DISCORD_TOKEN = (not set)');
    }
    if (idsMatch?.[1]) {
      const ids = idsMatch[1].trim().split(/[,\s]+/).filter(Boolean);
      const masked = ids.map((id) => (id.length > 6 ? `${id.slice(0, 3)}...${id.slice(-3)}` : '***'));
      console.log(`  DISCORD_ALLOW_USER_IDS = ${masked.join(', ')}`);
    } else {
      console.log('  DISCORD_ALLOW_USER_IDS = (not set)');
    }
    console.log('');

    const overwrite = await ask('Overwrite with fresh config? [y/N] ');
    if (overwrite.toLowerCase() !== 'y') {
      console.log('Run discoclaw init after removing .env to reconfigure.\n');
      completed = true;
      rl.close();
      return;
    }

    const bkName = backupFileName();
    const backupPath = path.join(cwd, bkName);
    fs.copyFileSync(envPath, backupPath);
    console.log(`  Backed up to ${bkName}\n`);
  }

  // ── Required values ───────────────────────────────────────────────────────

  const values: Record<string, string> = {};

  values.DISCORD_TOKEN = await askValidated('Discord bot token: ', (val) => {
    const r = validateDiscordToken(val);
    return r.valid ? null : (r.reason ?? 'Invalid token format');
  });

  values.DISCORD_ALLOW_USER_IDS = await askValidated(
    'Allowed user IDs (comma-separated): ',
    (val) => {
      if (!val.trim()) return 'At least one user ID is required';
      const r = validateSnowflakes(val);
      if (!r.valid && r.invalidIds.length > 0) return `Invalid IDs: ${r.invalidIds.join(', ')}`;
      if (!r.valid) return 'At least one valid snowflake ID is required';
      return null;
    },
  );

  values.DISCOCLAW_TASKS_FORUM = await askValidated(
    'Tasks forum channel ID (required): ',
    (val) => (validateSnowflake(val) ? null : 'Must be a 17-20 digit number'),
  );

  values.DISCOCLAW_CRON_FORUM = await askValidated(
    'Automations forum channel ID (required): ',
    (val) => (validateSnowflake(val) ? null : 'Must be a 17-20 digit number'),
  );

  // ── Runtime detection ─────────────────────────────────────────────────────

  const detected: string[] = [];
  if (which('claude')) detected.push('claude');
  if (which('gemini')) detected.push('gemini');
  if (which('codex')) detected.push('codex');

  if (detected.length > 0) {
    console.log(`\nDetected runtimes: ${detected.join(', ')}`);
  } else {
    console.log('\nNo AI runtimes detected in PATH.');
    console.log('  → Install Claude CLI: https://docs.anthropic.com/en/docs/claude-code');
  }

  // ── Provider selection ────────────────────────────────────────────────────

  console.log('\nSelect your AI provider:');
  console.log('  1) Claude' + (detected.includes('claude') ? ' (detected)' : ''));
  console.log('  2) Gemini' + (detected.includes('gemini') ? ' (detected)' : ''));
  console.log('  3) OpenAI');
  console.log('  4) Codex' + (detected.includes('codex') ? ' (detected)' : ''));

  const defaultProvider = selectDefaultProvider(detected);

  const providerChoice = await askValidated(
    `Provider [1-4, default: ${defaultProvider}]: `,
    (val) => {
      const effective = val || defaultProvider;
      return ['1', '2', '3', '4'].includes(effective) ? null : 'Enter 1, 2, 3, or 4';
    },
  );
  const finalChoice = providerChoice || defaultProvider;

  if (finalChoice === '1') {
    values.PRIMARY_RUNTIME = 'claude';
    const skipPerms = await ask(
      'Enable CLAUDE_DANGEROUSLY_SKIP_PERMISSIONS? (required for headless operation) [Y/n] ',
    );
    if (skipPerms.toLowerCase() !== 'n') {
      values.CLAUDE_DANGEROUSLY_SKIP_PERMISSIONS = '1';
    }
    const streamJson = await ask('Use stream-json output format? (smoother streaming) [Y/n] ');
    if (streamJson.toLowerCase() !== 'n') {
      values.CLAUDE_OUTPUT_FORMAT = 'stream-json';
    }
  } else if (finalChoice === '2') {
    values.PRIMARY_RUNTIME = 'gemini';
    console.log('  Note: auth is handled by the gemini binary itself (run `gemini` to authenticate).');
    const gemBin = await askOptional('Gemini binary path [default: gemini]: ', () => null);
    values.GEMINI_BIN = gemBin || 'gemini';
    const gemModel = await askOptional('Gemini model [default: gemini-2.5-pro]: ', () => null);
    values.GEMINI_MODEL = gemModel || 'gemini-2.5-pro';
  } else if (finalChoice === '3') {
    values.PRIMARY_RUNTIME = 'openai';
    console.log('  Note: the OpenAI adapter is HTTP-only.');
    values.OPENAI_API_KEY = await askValidated(
      'OpenAI API key: ',
      (val) => (val ? null : 'API key is required'),
    );
  } else if (finalChoice === '4') {
    values.PRIMARY_RUNTIME = 'codex';
    const codexBin = await askOptional('Codex binary path [leave empty to use PATH]: ', () => null);
    if (codexBin) values.CODEX_BIN = codexBin;
    const codexModel = await askOptional('Codex model [leave empty for default]: ', () => null);
    if (codexModel) values.CODEX_MODEL = codexModel;
    const bypassApprovals = await ask(
      'Enable CODEX_DANGEROUSLY_BYPASS_APPROVALS_AND_SANDBOX? [y/N] ',
    );
    if (bypassApprovals.toLowerCase() === 'y') {
      values.CODEX_DANGEROUSLY_BYPASS_APPROVALS_AND_SANDBOX = '1';
    }
  }

  // ── Recommended settings ──────────────────────────────────────────────────

  const configRecommended = await ask('\nConfigure recommended settings? [Y/n] ');
  if (configRecommended.toLowerCase() !== 'n') {
    const guildId = await askOptional(
      'Discord guild (server) ID [leave empty to skip]: ',
      (val) => {
        if (!val) return null;
        return validateSnowflake(val) ? null : 'Must be a 17-20 digit number';
      },
    );
    if (guildId) values.DISCORD_GUILD_ID = guildId;
  }

  // ── Optional features ─────────────────────────────────────────────────────

  const configOptional = await ask('\nConfigure optional features? [y/N] ');
  if (configOptional.toLowerCase() === 'y') {
    const actions = await ask(
      'Enable Discord Actions? (lets the AI manage your server) [y/N] ',
    );
    if (actions.toLowerCase() === 'y') {
      values.DISCOCLAW_DISCORD_ACTIONS = '1';
    }
    const statusChannel = await askOptional(
      'Status channel ID or name [leave empty to skip]: ',
      () => null,
    );
    if (statusChannel) values.DISCOCLAW_STATUS_CHANNEL = statusChannel;
  }

  // ── Write .env ────────────────────────────────────────────────────────────

  const envContent = buildEnvContent(values);
  const tmpPath = path.join(cwd, '.env.tmp');
  fs.writeFileSync(tmpPath, envContent, 'utf8');
  fs.renameSync(tmpPath, envPath);
  console.log('\n.env written successfully.\n');

  // ── Scaffold workspace ────────────────────────────────────────────────────

  const workspaceCwd = path.join(cwd, 'workspace');
  console.log(`Scaffolding workspace at ${workspaceCwd}...`);
  const scaffolded = await ensureWorkspaceBootstrapFiles(workspaceCwd);
  if (scaffolded.length > 0) {
    console.log(`  Created: ${scaffolded.join(', ')}`);
  } else {
    console.log('  Workspace already set up — no files changed.');
  }
  console.log('');

  // ── Next steps ────────────────────────────────────────────────────────────

  console.log('Configuration complete!\n');
  console.log('Next steps:');
  if (values.PRIMARY_RUNTIME === 'claude') {
    console.log('  discoclaw install-daemon');
  } else if (values.PRIMARY_RUNTIME === 'gemini') {
    console.log('  1. Authenticate: run `gemini` and follow the prompts.');
    console.log('  2. discoclaw install-daemon');
  } else if (values.PRIMARY_RUNTIME === 'openai') {
    console.log('  1. Verify your OPENAI_API_KEY is correct.');
    console.log('  2. discoclaw install-daemon');
  } else if (values.PRIMARY_RUNTIME === 'codex') {
    console.log('  1. Ensure the Codex binary is installed and accessible.');
    console.log('  2. discoclaw install-daemon');
  }
  console.log('');

  completed = true;
  rl.close();
}
